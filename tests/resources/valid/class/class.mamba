from Math import abs
import something

type MyType
    def fun_a: () -> ()
    def factorial: Int -> Int

# This class has no state
class MyClass[C, A isa MyGeneric](def my_field: Int) isa MyType[A, C](my_field)
    def SOME_CONSTANT <- 3.5E20

    def constant_func() => 400

type SomeState isa MyClass when z_modified > 2

type OtherState isa MyClass when
    z_modified > 10
    z_modified < 200
    other_field < 50

# This class does have state
class MyClass isa MyType
    def something: MyClass forward method_1, method_2

    def private z_modified
    def private mut other_field <- 10

    def init(mut self, my_field: Int, z: Int) =>
        if z > 10 then return Err("Something is wrong!")
        self.z_modified <- z * SOME_CONSTANT
        def a <- self.z_modified handle
            err1: MyErr =>
                print "hey"
                print "there"
            err2: MyErr => print "hoi"

    def connect(mut self: SomeState) => self.other_field <- 200

    def fun_a(self) => print self

    def private fun_b(self) => print "this function is private!"

    def factorial(self, x: Int <- 0) => x * self.factorial (x - 1)
    def factorial_infinite(self, x: Int) => x * self.factorial x

    def a(self) => self.a self.b
    def b(self, c) => self.a self.b self.c
    def c(self, d) => self.a self.b self.c d

    def some_higher_order (self, fun: Int -> Int) => 0
    def fancy(self) => self.some_higher_order(\x => x * 2)

class SimpleClass
    def something

    def init(self, something: S) =>
        self.something <- something